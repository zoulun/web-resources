# web-resources
## 前端资源汇集

[前端资源汇集](https://www.jeffjade.com/2016/03/30/104-front-end-tutorial/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)

[InterviewMap](https://yuchengkai.cn/docs/frontend/)

[JavaScript 九种跨域方式实现原理](https://segmentfault.com/a/1190000018129152?utm_source=tag-newest)

[前端面试查漏补缺](https://juejin.im/post/5c6e6063f265da2da53ec8f3)

[React中setState真的是异步的吗](https://juejin.im/post/5ac1aaad6fb9a028d444bb87)

[setState异步、同步与进阶](https://juejin.im/post/5bf1444cf265da614a3a1660)

[函数防抖和节流](https://www.jianshu.com/p/c8b86b09daf0)

[JavaScript的面向对象的理解](https://www.jianshu.com/p/44ddfb089a11)

[我对函数式编程的理解](https://zhuanlan.zhihu.com/p/47635295)

[require（）方法引用规则解释](https://blog.csdn.net/m0_48459838/article/details/113836994)

[get请求和post请求的详细区别](https://blog.csdn.net/zlczsw/article/details/91046081)

[js事件循环机制](https://blog.csdn.net/weixin_43842373/article/details/124485407)

# node
[Node.js 优秀学习资源汇总](https://www.jianshu.com/p/e37835da4624)



基础
1. Reflect是什么，有什么作用
Reflect是什么，有什么作用
可以完成对象的基本操作，也就是说直接调用对象的基本方法。js中有多种方式操作对象，无论是语法还是函数来操作对象，比如对象属性的增删改查，是间接完成对象的基本操作，也就是指的语言底层没有暴露的内部方法，如[[Get]]、[[Set]]、[[Delete]]和函数的[[Call]]、[[Construct]]，基本操作是不能直接使用的

2.proxy是拦截对象的基本操作，对象基本操作参考1
proxy和defineProperty的区别
defineProperty是众多基本操作之一的[[DefineOwnProperty]]，功能有局限性，只能对已有的属性读写

3.derfer、async、prefetch、preload作用和执行时机
derfer：不阻塞dom解析，dom解析完成后按顺序执行
async：不阻塞dom解析，文件下载完成后立即执行，不能保证顺序
prefetch：预加载，不阻塞解析，优先级高，立即加载
preload：预加载，不阻塞解析，优先级低，空闲时加载

4.闭包和内存泄露
内存泄露：有垃圾没有被回收，垃圾回收机制有引用计数和标记清除
闭包：函数加词法环境，函数内部所引用的变量会保存在内存中，也就是词法环境没法销毁

闭包和内存泄露的关系
● 如果一个本应该被销毁的函数没有被回收，会导致其关联的词法环境也无法回收，从而可能导致大量内存泄露
● 当多个函数共享一个词法环境时，可能会造成词法环境的膨胀，从而出现无法访问且无法回收的的内存，造成内存泄露（浏览器bug）


5.如何理解JS异步
Js是单线程的，异步会和浏览器的渲染、事件循环有关。
HTML解析、css解析、js运行等都在渲染主线程中运行，如果使用同步的话，就有可能导致渲染主线程阻塞导致的卡死现象，所以浏览器采用异步的方式来避免，比如计时器、网络请求、事件监听加入到消息队列末尾排队，等待浏览器主线程调度执行，这样就能避免单线程的流畅运行。

6.事件循环：
事件循环也叫消息循环，是浏览器的渲染主线程的工作方式（事件循环是单线程语言实现并发的核心机制，它通过调用栈、任务队列和渲染管道的协同工作来处理异步操作。其核心运行逻辑是：执行一个宏任务 → 清空所有微任务 → 执行渲染 → 重复循环。），在执行js脚本时会有同步和异步任务之分，在执行到异步任务时会将任务分配到不同的消息队列里面等待执行，在chrome源码中会开启一个无限循环，每次循环都会从消息队列里面取出第一个任务执行。过去把任务队列简单分宏任务和微任务，现在随浏览器复杂度提升，已经无法满足浏览器环境了。
根据W3C官方的解释，每个任务有不同的类型，同类任务必须在同一个队列，不同任务可以属于不同队列，不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务，但必须有一个微队列，微队列任务具有最高优先级。队伍队列的优先级微任务队列》事件监听消息队列》计时器消息队列。依次取出直到全部执行完
，
7.消息队列：
浏览器复杂度提升，w3c取消了宏队列的说法，每个任务都有一个任务类型，同一个类型的任务必须在一个队列，一个列队可以包含不同的任务类型。
浏览器必须有一个微队列

单线程是异步产生的原因
事件循环是异步的实现方式

8.js计时器为什么不精确
    8.1.硬件方面，没有原子钟，是靠cpu计时
    8.2.操作系统，浏览器api最终是调用操作系统实现的计时，操作系统本身也不精确
    8.3.web标准，settimeout嵌套超过5层会有4mm的延迟，时间循环也会造成延迟，浏览器标签页失活状态会有1ms的延迟

9.react任务调度
    使用的messagechannel，不使用requestIdleCallback原因：1.执行频率低，只有20FPS。2.没有优先级控制。3.依赖浏览器空闲时间，不能主动时间切片，用户交互响应
    meesagechannel模拟req原理，在调用msg时用当前时间preformance.now()判断是否大于等于上一次渲染结束时间+5mm果为ture时间耗尽

10.事件循环
    JavaScript 事件循环是单线程语言实现并发的核心机制，它通过调用栈、任务队列和渲染管道的协同工作来处理异步操作。其核心运行逻辑是：执行一个宏任务 → 清空所有微任务 → 执行渲染 → 重复循环。

11.let  var区别
● 全局污染
● 块级作用域
● 暂时性死区，先定义再使用
● 重复声明

12.为什么要使用虚拟dom
●     框架涉及有关，react  vue数据驱动型，框架本身的设计，颗粒度最小是组件，更新的太频繁产生效率问题
● 跨平台，不跟真实dom绑定，用js对象用来描述UI，可以用于多个平台

13.作用域和作用域链
    指的是函数和变量生效的区域，可分为全局作用域、函数作用域、块级作用域
    作用域链：js中使用某个变量时，js引擎会尝试在当前作用域下寻找这个变量，如果没有找到，会向上层作用域继续寻找，直到找到变量或者已经到最上层作用域还没有找到就报错，这一连串的操作就是作用域链

14.为什么要使用模块化，模块化作用。
    随着项目代码量和文件的增加，会存在大量的全局变量污染，和文件之间的依赖，加大了开发和维护成本。衍生出了很多三方模块，项目中使用的三方模块多了后也存在了管理三方模块的问题（安装，卸载，使用不同版本模块等问题），因此出现了包管理器，模块化可以解决这些问题。

15.href和src的区别
href：引用资源，不阻塞渲染
src：引入资源，阻塞渲染

16.javascript类型
基本类型：string、number、boolean、null、undefined、symbol、bigint，引用类型：object

17.call、apply、bind原理
call、apply区别，call传参是挨个传入、apply是数组
原理，testFn.call(obj, '测试')，会在obj对象下创建一个临时的属性用来存testFn，也就是调用时的this，在调用这个obj属性下的这个方法并且传入参数，如：const res = obj['test'](...args)，然后再删除这个临时属性，最后返回res
bind是不会执行调用的函数，内部会返回一个函数，其他与call类似

18.promise规范和promise解决的问题
promise A+规范，统一了异步处理模型，只要一个对象满足有then方法就是promise
解决了：1.同意标准。2.回调地狱。3.同意的错误捕获。4.并发控制，promise.all  promise.race

19.axios拦截器原理

20.1. instanceof，检测构造函数的prototype是否出现在某个实例对象的原型链上

21.三次握手四次挥手
握手：客服端向服务器发送一个syn包
服务器在接收到syn包后，想客服端发送syn和ACK的包
客服端在接收到这两个包后会向服务器发送ACK包的确认，三次握手结束
三次握手的目的，是为了防止已经失效的请求报文又传回到了服务器，而产生错误

客服端向服务器发送一个FIN，用来关闭数据传输
服务器在收到后会发送一个ACK给+1序列号给客服端
服务器发送一个FIN给客服端，通知客服端响应报文发送完成
客服端接收到后会向服务器发送一个ACK，序列号+1，完成四次挥手

22.手写new操作
创建一个新对象
把构造函数的prototype赋值给新对象的__proto__
再调用构造函数appyl改变this指向到新对象，获取调用后的返回值
判断返回值是否是对象，如果是对象就返回这个值，如果不是就返回新创建的对象

23.将多参数的函数转换成单参数的函数，特点是，参数复用，提前返回，延迟执行。原理，利用闭包把接收到的参数保存在作用域用，等待最后使用，并返回一个新函数继续接收剩余参数。

24.node模块查找
带有斜杠前缀
1.文件查找
带有斜杠路径，直接查找文件，会默认补后缀名‘js’或‘json’，找不到会进入第二种查找
2.文件夹查找
首先会查找对应目录文件夹，找到文件夹后会默认找index.js，如果没有会找package.json，默认读取package.json的main字段，找不到就报错

没有斜杠前缀
3.内置模块查找
首先检查有没有对应的内置模块，有没有通过fs模块引用
4.三方模块查找
没有内置模块的话会从node_modules查找，查找逻辑就会跟文件、文件夹查找一样

25.for in和for of区别
for in是用来迭代对象可枚举的属性，数组是下标，对象是key
for of是用来遍历可迭代对象，数组、Map、Set等，prototype有[symbol.interator]

26.什么是词法环境
是变量和函数作用域的管理机制


react
1. hook的有什么用
优势：为函数组件提供像类组件一样有状态、生命周期的功能，作用是复用性、简洁性，不用像类组件需要用绑定this
缺点：只能在顶层调用，不能在if或者循环中使用，会导致顺序混乱
2. react的Fiber是什么，有什么作用
Fiber是react新的协调引擎，解决了旧版本中更新效率问题，如任务无法中断、拆分任务、更新卡顿等，Fiber可以对任务拆分、中断、处理高优任务（比如用户交互）。本质上是一种链表数据结构，用来描述组件的相关信息，tag、return、child、sibling、memoizedState(hook链表存储)
双缓存，workInProgress复用current Fiber树，执行计算更新，切换指针到current Fiber树，最后再执行DOM更新，好处是如果计算更新中出现问题，可以回退不再继续做后续更新操作
使用的messagechannel，不使用requestIdleCallback原因：1.执行频率低，只有20FPS。2.没有优先级控制。3.依赖浏览器空闲时间，不能主动时间切片，用户交互响应
    messagechannel模拟req原理，在调用msg时用当前时间preformance.now()判断是否大于等于上一次渲染结束时间+5mm果为ture时间耗尽
3. 1
4. 1
5. 1
6. 1
7. 1
8. 11
9. 1
10. 1
11. 1
12. 

网络
1. 页面加载后发生大量Ajax请求，如何优化
● BFF，后端中间层微服务合并请求
● 请求队列优先级控制
● 请求缓存，协商缓存
● 压缩，gzip
● CDN
● 多域名并发，http1.1版本下浏览器同一时间点对同一个域名只能同时发出6条请求，因此需要做多域名并发突破限制
● http2，版本低的浏览器不支持

2.频繁请求，不能保证顺序返回的情况下，如何只取最后一次发起请求的返回
● 前端带id请求并记录最后一次请求id，接口返回带上id，对比是不是最后一次id。
● 取消上一次发起的请求，xhr.abort（）、fetch可以用new AbortController（）、axios取消请求

3.输入url后过程：
分为两个方面
3.1、网络
3.2、渲染

网络：
网络进程  拿到HTML字符串

渲染：
当浏览器的网络线程收到HTML文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列

渲染主线程：解析HTML》生成DOM树和CSSOM树》计算样式（每个DOM得到最终的样式）》布局（计算出每个DOM节点的几何信息）》分层（根据一套策略，分成多个图层，可用will-change控制分层，勿滥用）》绘制（生成绘制指令）
合成线程：分块（分块会将每一层分为多个小区域）》光栅化（将每个分块变成位图，也就是像素点信息，优先处理靠近视口的块）》画（计算出每个位图在屏幕上的位置信息，交给GPU进行呈现）
Transform是在画的流程进行，所以transform的效率高的原因

4.缓存有哪些
1.强缓存：优先级cache-control：max-age  >  expires
2.协商缓存：
响应体里last-modified，这个资源在服务器上最后修改时间，浏览器下一次向服务器发起请求时，请求头上会带上if-modified-since，这个值就是last-modified的值，服务器在接收到if-modified-since后会和最后一次修改时间对比，如果一样就返回304，缺点是以秒为单位，小于秒的高频更新，用此方式效果不佳；
ETag和if-None-Match，和上面一样，但返回的是字符串，只要资源有修改，字符串就不同，缺点是需要对资源进行标识，性能方面有所牺牲
优先级：ETag和if-None-Match >  last-modified和if-modified-since


工程化
一、 如何清理源码里面没有应用的代码，js、css
● eslint、Terser：源码文件解析，然后通过AST抽象语法树分析，只能支持js文件和单模块
● Tree Shaking支持多模块，是把整个工程一起分析的，a模块导出了，其他模块没有用也能分析出来，只支持js、ESM导入标准，编译时态进行静态分析，动态导入不支持
● PurgeCss，针对css，对整个工程进行分析，可以分析出样式有哪些类在页面里面没有用到
● 自定义

2.什么是AST，它在前端的应用
AST   abstract syntax tree 抽象语法树，他是用于表达源码的数据结构，acorn库可以用来解析转化成抽象语法数据
应用：
● 代码转换，打包工具，babel，代码压缩
● 检查代码，格式化，eslint，prettier

3.webpack核心功能
1.打包压缩、2.文件指纹（防止文件缓存）、本地开发服务器

4.webpack打包流程
● 初始化阶段
在输入执行命令后，会读取到对应的webpack.config文件
● 编译阶段
获取入口文件entry配置，从入口文件开始递归分析依赖，对不同后缀名文件使用配置的loader进行转换，生转换成抽象语法树（AST）
● 生成阶段
根据入口以来关系进行文件分割，以及plugins插件的调用
● 输出阶段
转换成最终的资源文件后，根据output输出到对应目录

5.loader和plugins区别
loader：代码编译（语法转换、代码检查等），编译早期执行，性能更好
plugin：编译后的代码功能扩展，代码压缩、代码分割优化等，编译后期，会遍历整个代码，性能略差

6.webpack热更新原理
客户端和服务端建立了websocket，当本地服务端资源有更新会主动推送到客户端进行更新
难点亮点
从项目背景入手，提出解决方案，实现过程中遇到的问题及处理，最终的效果

其他面试链接
主：https://github.com/zoulun/web-resources
查漏补缺：https://juejin.cn/post/6844903781084184584
